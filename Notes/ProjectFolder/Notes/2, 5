
Client -> internet -> entry point -> backend -> data store

Client -> internet -> Web server -> web framework  -> backend -> data store

Entry point is a 
Web server: job is to listen for HTTP traffic
Web framework: job is to be an abstraction layer for HTTP(turning the bytes into objects) our web framework is ASP.NET Core


http://your-server.com 

{
	Username: ‘bob”
	Password: “123456”
}

All info above comes in the form of a TCP/IP data frame or datagram.
By using a framework everything automatically gets translated as well as managing ports 


SPA -> internet -> Microservices

Microservices(web service) 
Web server
Web framework
Web service
Webs service
SOAP (Simple Object Asynchronous Protocol)(XML Format)
REST (JSON format) easiest and simplest way
gRPC (BSON format)


REST: relying on HTTP verbs and HTTP status codes to dictate how services work
HTTP Verbs:
GET: get data from server to client
POST: send data from client to server == creation
PUT: modify existing data == update
DELETE: delete existing data on server
PATCH

Status codes:
100s = 101 - 199 meaning reached the server(HEAD command, to check if the server is alive)
200s = 200 - 299 different meanings of success
300s = 301 temporary move of data, 302 permanent move of data
400s = 401 authentication problem, 403 authorization problem, 404 missing content
500s = 500 server error

Ex. 
HTTP POST -> web service -> return 200(means ok)
HTTP POST -> web service -> return 500(internal server error)
HTTP POST -> web service -> return 400(Bad Request)

HTTP GET -> web service -> return 200 + payload

Dotnet new update

Dotnet new list (to get  a list of templates to use)


To make a MVC application then use the mvc command

Web API == Web Service\



Initial Setup



Creates a developer certificate, installs the certificate on the local machine to use HTTPS


If we are using firefox etc, follow the steps here.

UserManagementController, 

Each controller has different microservices, that all belong to the same host, this creates a  single point of failure situation.

Instead we can do isolation by process, which means we can create multiple controller files for each process (microservices) 

Typically all microservices are run on different servers.. To avoid single point of failure

Start with authentication, and authorization services and Archiving.. Then start with the application-specific microservices 


